[TOC]

# redis高可用之集群

​	redis集群是redis提供的分布式数据库解决方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。

## 1、节点

​	一个redis集群通常由多个节点组成，刚开始，每个节点都是相互独立的，他们处于一个只包含自己的集群当中，要组建一个真正可用的集群，我们必须将各个独立的节点连接起来。

​	redis集群的数据结构主要有三种，clusterNode、clusterLink、clusterState。

- **clusterNode**

  ```c++
  struct clusterNode {
  	mstime_t ctime;
      char name[REDIS_CLUSTER_NAMELEN];
      int flags;
      uint64_t configEpoch;
      char ip[REDIS_IP_STR_LEN];
      int port;
      clusterLink *link;
      clusterState *state;
      unsigned char slots[16384/8];
      int numslots;
      clusterNode *slaveof;
      list *fail_reports;
  }
  ```

  ​        **ctime**是节点创建时间；**name**是节点名称，由40个字符组成；**flags**是节点标识，使用不同的标识记录节点的角色（主节点或从节点）、节点目前所处的状态（在线或下线）；**configEpoch**是节点当前的配置纪元，用于故障转移；**ip**是节点的ip；**port**是节点的端口号；**link**指针保存了节点的连接信息；**state**指针保存了在当前节点的视角下，集群目前所处的状态；**slots**记录了该节点处理哪些槽；**numslots**记录了该节点处理的槽的数量；**slaveof**是指向主节点的指针；**fail_reports**是一个保存了集群中的其他节点对该节点的下线报告。

- **clusterLink**

  ```c++
  struct clusterLink {
  	mstine_t ctime;
      int fd;
      sds sndbuf;
      sds rcvbuf;
      clusterNode *node;
  }
  ```

  ​        **ctime**是连接建立时间；**fd**是TCP套接字描述符；**sndbuf**是输出缓冲区，保存着发送给其他节点的信息；**rcvbuf**是输入缓冲区，保存着从其他节点接收的消息；**node**指针指向与这个节点连接的节点，若没有则为null。

- **clusterState**

  ```c++
  struct clusterState {
  	clusterNode *myself;
      uint64_t currentEpoch;
      int state;
      int size;
      dict *nodes;
      clusterNode *slots[16384];
      zskiplist *slots_to_keys;
      clusterNode *importing_slots_from[16384];
      clusterNode *migrating_slots_to[16384];
      int numslaves;
      clusterNode **slaves;
  }
  ```

  ​		**myself**是指向当前节点的指针；**currentEpoch**是集群当前的配置纪元，用于故障转移；**state**记录了集群当前的状态（在线还是下线）；**size**是集群中至少处理着一个槽的节点的数量；**nodes**是集群的节点名单，字典的键为节点的名字，字典的值为指向节点的clusterNode结构的指针；**slots**记录了集群中16384个槽的指派信息；**slots_to_keys**是一个跳跃表结构，保存了槽和键之间的关系，节点的分值是槽号，节点的成员是一个数据库键；**importing_slots_from**数组记录了当前节点正在从其他节点导入的槽；**migrating_slots_to**数组记录了当前节点正在迁移至其他节点的槽；**numslaves**是复制这个主节点的从节点数量；**slaves**数组中的每一项指向复制这个主节点的一个从节点。

- `CLUSTER MEET`命令的实现

   	通过向节点A发送`CLUSTER MEET`命令，可以让接受命令的节点A将另一个节点B添加到A所在的集群中，收到命令的节点A会与节点B进行握手以确认彼此的存在。

  - [ ] 节点A会为节点B创建一个clusterNode结构并将该结构添加到自己的clusterState.nodes字典中
  - [ ] 节点A会根据命令中的IP和端口号向节点B发送一条MEET消息
  - [ ] 节点B收到节点A的MEET消息后，会为节点A创建一个clusterNode结构并将该结构添加到自己的clusterState.nodes字典中
  - [ ] 之后，节点B将向节点A返回一条PONG消息
  - [ ] 节点A收到节点B的PONG消息后，会知道节点B已经成功地接收到了自己发送的MEET消息，之后A会向B发送一条PING消息
  - [ ] 节点B接收到节点A返回的PING消息后，直到节点A已经成功地接收到了自己返回的PONG消息，握手完成
  - [ ] 之后，节点A 会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也和B节点握手，最终，节点B会被集群中的所有节点认知

  

## 2、分片

​	redis集群通过分片的方式保存数据库中的键值对，集群中的数据库被划分为16384个槽，数据库中的每个键都属于其中的一个槽，集群中的每个节点可以处理0-16384个槽。当数据库中的16384个槽都有节点处理，则集群处于上线状态，否则，只要有一个槽没有节点处理，整个集群都处于下线状态。

​	clusterNode结构的slots属性记录了节点负责处理哪些槽，slots是一个二进制位数组，数组长度为16384/8=2048个字节，包含16384个二进制位。以0为起始 索引 ，16383为终止索引，对slots中的16384个槽进行了编号，根据索引i上的二进制位的值判断该节点是否处理这个槽（二进制位为1表示处理这个槽，为0表示不处理这个槽）。一个节点除了会将自己处理的槽信息记录在clusterNode.slots中之外，还会将自己的slots数据用消息发送给集群中的其他节点，以此告知其他节点自己负责的槽信息。

​	clusterState结构中的slotss属性记录了负责索引为i的槽的节点信息，slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针，如果指向null，说明这个槽尚未指派给任何节点。

​	当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会在自己的nodes字典中找到B节点对象的数据结构，将B节点的slots数组进行保存或更新。因为集群中的每个节点都会将自己的slots数组信息通过消息发送给其他节点，且收到消息的节点会将数组保存到相应节点的对应的clusterNode结构中。因此，集群中的每个节点都会知道数据库中的16384个槽分别指派给了集群中的哪些节点。

​	当对数据库中的16384个槽都进行了指派后，集群会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了。当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出键所属的槽，并检查这个槽是否指派给了自己，若是，则直接执行命令即可；若不是，则向客户端返回一个MOVED错误，指引客户端转向正确的节点并再次执行该命令。

### 重新分片

​	redis集群的重新分片可以将任意数量已经指派给某个节点的槽改为指派给另一个节点，并且相关槽所属的键会从源节点迁移到目标节点。重新分片操作可以在线执行，在重新分片过程中，集群不需要下线，且源节点和目标节点都可以处理命令请求。

​	在重新分片期间，源节点向目标节点迁移过程中，可能会出现属于被迁移槽的一部分键既存在于源节点，又存在于目标节点。当客户端向源节点发送一个与数据库键有关的命令，而这个键刚好处于正在被迁移的槽中，源节点会先在自己的数据库中查找，若能找到则执行相应的命令，否则向客户端返回一个ASK错误，指导客户端转向正在执行导入槽的目标节点并再次执行该命令。



## 3、复制和故障转移

​	redis集群中的节点分为主节点和从节点，其中，主节点用于处理槽，从节点用于复制某个主节点，当主节点下线时，从节点提升为主节点，代替被复制的已下线从节点处理命令请求。

​	一个节点成为从节点，并开始复制某个主节点的信息会通过消息发送给集群中的其他节点，最终集群中的所有节点都会知道这个从节点正在复制某个主节点。

	### 故障检测

​	集群中的每个节点都会定期向集群中的其他节点发送PING消息，以此来检测对象是否在线，若接收PING消息的节点没有在规定时间内向发送PING消息的节点返回PONG消息，那么发送消息的节点会将接收消息PING的节点标记为疑似下线。

​	集群中的各个节点会通过互相发消息的方式来交换集群中的节点状态信息，当在一个集群中，半数以上负责槽的主节点都将某个主节点x报告为疑似下线，那么主节点x被标记为已下线，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会将x标记为已下线。

### 故障转移

​	当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将会对主节点进行故障转移：

- 复制主节点的所有从节点中，会有一个从节点会被选中，执行`SLAVEOF no one`成为新的主节点
- 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽指派给自己
- 新的主节点会向集群广播一条PONG命令，告知集群中的其他节点，这个节点已经由从节点变成了主节点，并且已经接管了所有已下线节点的负责处理的槽
- 新的主节点开始接收和自己负责处理的槽有关的键的命令请求，故障转移到此完成

### 主节点选举流程

​	新的主节点通过选举产生：

- 集群中的配置纪元是一个自增计数器，初始值为0
- 当集群中的某个节点开始一次故障转移操作时，配置纪元加一
- 对于每个配置纪元，集群中负责处理槽的主节点都有一次投票机会，且第一次向主节点要求投票的从节点将获得主节点的支持
- 当从节点发现自己复制的主节点状态进入已下线时，从节点会向集群广播一条`CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST`消息，要求收到这条消息且有投票权的主节点主节点向这个从节点投票
- 若一个节点有投票权，且该主节点尚未投过票，则主节点向要求投票的从节点返回一条`CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK`消息，表示支持这个从节点成为主节点
- 每个参与选举的从节点都会受到`CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK`消息，并根据收到的条数统计自己获得了多少个主节点的支持
- 若某个节点得到了半数以上的支持，则这个从节点就会当选为新的主节点
- 因为在一个配置纪元中，每个具有投票权的主节点只能投票一次，所以得到半数以上投票的从节点最多只会有一个，这确保了新的主节点只会有一个
- 如果在一个配置纪元中没有从节点能够收集到足够多的支持票，那么集群进入一个新的配置纪元，选举重新开始，直到选出新的主节点为止



## 参考文献

redis设计与实现